<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plasma Dynamics Research Lab: 30° Conical Geometry</title>

    <!-- External Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #0c0c0e; }
        ::-webkit-scrollbar-thumb { background: #3f3f46; border-radius: 4px; }
        #simCanvas { background-color: #050505; border-radius: 1rem; width: 100%; height: 450px; cursor: crosshair; }
        .glass-panel { background: rgba(24, 24, 27, 0.6); backdrop-filter: blur(12px); border: 1px solid rgba(63, 63, 70, 0.5); }
    </style>
</head>

<body class="bg-[#0c0c0e] text-zinc-300 font-sans leading-relaxed">

<!-- (HTML BODY CONTENT UNCHANGED — OMITTED FOR BREVITY) -->
<!-- KEEP EVERYTHING EXACTLY AS YOU HAD IT ABOVE -->

<script>
    const state = {
        v0: 30,
        delay: 50,
        cap: 1e-6,
        tau: 72.13,
        mode: 'blunt',
        isAnimating: false
    };

    let energyChartInstance = null;

    function initCharts() {
        const ctx = document.getElementById('energyChart').getContext('2d');
        if (energyChartInstance) energyChartInstance.destroy();

        const labels = Array.from({ length: 61 }, (_, i) => i);
        const vData = labels.map(t => (t <= state.delay) ? 30 * Math.exp(-t / state.tau) : null);
        const lossData = labels.map(t => {
            if (t > state.delay) return null;
            const v = 30 * Math.exp(-t / state.tau);
            return 0.5 * (900 - v * v);
        });

        energyChartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                labels,
                datasets: [
                    { label: 'Voltage (kV)', data: vData, borderColor: '#6366f1', borderWidth: 3, pointRadius: 0, yAxisID: 'y' },
                    { label: 'Energy Loss (J)', data: lossData, borderColor: '#f59e0b', borderWidth: 2, pointRadius: 0, fill: true, backgroundColor: 'rgba(245,158,11,0.05)', yAxisID: 'y1' }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: { grid: { color: '#18181b' }, title: { display: true, text: 'Time (µs)' } },
                    y: { min: 0, max: 35, title: { display: true, text: 'Voltage (kV)' }, grid: { color: '#18181b' } },
                    y1: { min: 0, max: 450, position: 'right', grid: { display: false }, title: { display: true, text: 'Waste Heat (J)' } }
                }
            }
        });
    }

    let simCanvas, simCtx, ions = [];

    function initSim() {
        simCanvas = document.getElementById('simCanvas');
        simCtx = simCanvas.getContext('2d');

        const resize = () => {
            simCanvas.width = simCanvas.parentElement.clientWidth;
            simCanvas.height = 450;
            drawStage();
        };
        window.addEventListener('resize', resize);
        resize();

        document.getElementById('btnTrigger').addEventListener('click', runPulse);
    }

    function setMode(mode) {
        state.mode = mode;
        state.delay = mode === 'blunt' ? 50 : 22;
        initCharts();
        drawStage();
    }

    function drawStage() {
        const w = simCanvas.width;
        const h = simCanvas.height;
        simCtx.fillStyle = '#050505';
        simCtx.fillRect(0, 0, w, h);

        simCtx.fillStyle = '#27272a';
        if (state.mode === 'blunt') {
            simCtx.fillRect(w / 2 - 40, 0, 80, 60);
        } else {
            simCtx.beginPath();
            simCtx.moveTo(w / 2 - 40, 0);
            simCtx.lineTo(w / 2 + 40, 0);
            simCtx.lineTo(w / 2, 120);
            simCtx.fill();
        }
        simCtx.fillRect(w / 2 - 120, h - 20, 240, 20);
    }

    function runPulse() {
        if (state.isAnimating) return;
        state.isAnimating = true;

        let t = 0;
        ions = Array.from({ length: 150 }, () => ({
            x: (Math.random() - 0.5) * 200 + simCanvas.width / 2,
            y: Math.random() * (simCanvas.height - 120) + 80,
            type: Math.random() > 0.5 ? 1 : -1
        }));

        function frame() {
            drawStage();
            const vNow = 30 * Math.exp(-t / state.tau);
            ions.forEach(ion => {
                ion.y += ion.type * (vNow / 30) * 3.5;
                simCtx.fillStyle = ion.type > 0 ? '#8b5cf6' : '#f59e0b';
                simCtx.beginPath();
                simCtx.arc(ion.x, ion.y, 1.2, 0, Math.PI * 2);
                simCtx.fill();
            });

            t += 0.5;
            if (t < state.delay) {
                requestAnimationFrame(frame);
            } else {
                state.isAnimating = false;
                drawStage();
            }
        }
        frame();
    }

    // ✅ THIS IS THE FIX
    window.onload = () => {
        initSim();
        setMode('blunt');
        initCharts();
    };
</script>

</body>
</html>
